##Реализация боковой (Off-Canvas) навигации для адаптивного сайта

Разнообразие областей просмотра, с которыми ежедневно сталкиваются наши сайты, продолжают требовать большего от адаптивного дизайна. Мы должны не только продолжать решать задачи [хореографии контента][1] — искусства поддержания порядка и связности при любом хаотическом изменении браузера — но также и **соответствовать ожиданиям пользователей**. А они не стоят на месте.

С появлением таких операционных систем, как [Firefox OS][2] (на базе Gecko), [Chrome OS][3], а теперь и [Ubuntu для смартфонов][4], которые делают “веб-приложения” гражданами первого сорта, становится необходимым перенос поведения нативных приложений в веб, если пользователи начинают этого ожидать. Многие в нашей области аргументируют степень разделения между веб- и нативными приложениями техническими и философскими причинами. Они мудро призывают быть осторожными, но поскольку потребительские устройства продолжают размывать границы, стоит подумать, что мы можем перенять из дизайна нативных приложений.

###Демонстрация

В этой статье я по шагам построю пример, который коснётся двух тем. Первая — [шаблон адаптивного дизайна][5], который охватывает область просмотра и улучшает возможность обнаружения содержимого, скрытого за одной ссылкой; в данном случае , **боковой навигации**. Вторая — это сложности реализации таких идей с точки зрения доступности и производительности. Я уверен, что в будущем эти две темы будут основными в веб-разработке.

Учитывая вышесказанное, давайте начнём.

###Открытая для доступа основа

Все хорошие вещи начинаются с прочного фундамента из семантической HTML-разметки и легко поддерживаемых стилей CSS. В теории, эта основа должна нормально функционировать для всех браузеров, посетивщих най сайт. (Для устаревших браузеров это может быть *окончательным* поведением.)

В качестве отправной точки, я буду использовать метод, очень схожий с методом Аарона Густафсона “[Умная мобильная навигация без трюков][6]”, который не требует JavaScript для работы.

![Адаптивное боковое меню — Пример 1](img/demo-1-500.png?raw=true&repo=off-canvas-navigation-for-responsive-website "Пример 1")

*Шаг 1 адаптивного бокового меню. Короткая ссылка: [bit.ly/offcanvas1][7]*

- [Пример 1][8]<br>
Обязательно посмотрите на мобильной устройстве или в маленьком окошке браузера, изучите код в инспекторе. Хотя наш окончательный пример будет значительно отличаться, простой начальный пример очень важен; улучшение доступности — нетривиальная задача.

Разметка HTML выглядит примерно так (я немного упростил код для лучшего понимания смысла):

~~~~ .language-html
<header id="top" role="banner">
    <h1>Book Title</h1>
    <a href="#nav">Book navigation</a>
</header>
<nav id="nav" role="navigation">
    <h2>Chapters</h2>
    <ul>
        <li><a href="#">Chapter 1</a></li>
        <li><a href="#">Chapter 2</a></li>
        <li><a href="#">Chapter 3</a></li>
        <li><a href="#">Chapter 4</a></li>
        <li><a href="#">Chapter 5</a></li>
    </ul>
    <a href="#top">Return to content</a>
</nav>
<article role="main">
    <!-- [main content here] -->
</article>
~~~~

Можно рассмотреть только HTML, почти без стилей, как “нулевую точку”. Если на данном этапе это не логично, то мы не сможем улучшить доступность и в дальнейшем.

####АНАЛИЗ ПРИМЕРА 1

- Media queries написаны для области просмотре в 45em (это зависит от контента). Если область просмотре шире, то навигация видна постоянно. Я предпочитаю использовать em, потому что это позволяет поддерживать относительный размер шрифта. Лайза Гарднер подробно объясняет это в своей публикации “[У меня EM: Пропорциональные Media Queries. Поехали!][9]”
- Я использую как `min-width`, так и `max-width` в media queries в рамках CSS. Это немного добавляет сложности. Большинство людей предпочитают концепцию “mobile-first”, использующую только постепенное увеличение `min-width`. Недостаток этого подхода в большом количестве **сбросов**, необходимых в случае, когда элемент имеет различные визуальные представления. Идеальных методов не существует.
- Суть первого этапа — [псевдо-класс :target][10], используемый для показа и сокрытия навигации. Но IE8 и ниже его не поддерживают. Однако єто не проблема, если вы используете semi-fluid стили для старых IE. [Джейк Арчибальд][11], [Николас Галлахер][12] и [Стюарт Робсон][13] могут рассказать вам больше.

Поскольку демонстрационный пример принимает форму, я продолжу представлять основные принципы разработки. Это долгий путь, хотя…

###Строим боковую навигацию

Для многих сайтов достаточно того, что уже описано — но не для нас! Мы экспериментируем с паттерном боковой навигации и стремимся почерпнуть опыт использования нативных приложений. Поскольку мы не можем игнорировать старые браузеры, применим концепцию **постепенного улучшения**.

![Адаптивное боковое меню — Пример 2](img/demo-2.png?raw=true&repo=off-canvas-navigation-for-responsive-website "Пример 2")

*Шаг 2 адаптивного бокового меню. Короткая ссылка: [bit.ly/offcanvas2][14]*

- [Пример 2][15]<br>
Вы увидите переделанную навигацию с базовой функциональностью.

####АНАЛИЗ ПРИМЕРА 2

- Я добавляю класс `js-ready` к элементу документа после того, как произойдёт событие [DOMContentLoaded][16]. Флаг `.js-ready` используется в для безопасного преобразования навигации в боковую. Если по каким-то причинам JavaScript *не загружен*, то продолжит работать функционал из примера 1.
- Для показа и сокрытия навигации, я добавляю или убираю `js-nav` у элемента документа, когда пользователь кликает (или касается пальцем) на соответствующую кнопку. Это просто добавляет свойство `left: 70%` к элементу `#inner-wrap` (`#outer-wrap` используется для того, чтобы избежать появления скролла).

Это довольно простое улучшение, но оно важно, поскольку позволяет использовать функционал страницы до загрузки JavaScript. Также отметим, что отсутствуют инлайн-стили, устанавливаемые через JavaScript; для управлением состояниями используются только классы.

Резкое переключение между открытым и закрытым состояниями навигации раздражает пользователей. Им хотелось бы понимать и видеть как меняется интерфейс. Очень часто в веб-приложениях разработчики это упускают. Справедливости ради, разработка пользовательских интерфейсов — дело непростое. То, что я собираюсь продемонстрировать ниже, далеко от совершенства, но это, определённо, шаг в верном направлении.

Итак, настройка завершена. Теперь давайте добавим переходы.

###Переходы (неправильный путь)

Я сперва сделаю всё неправильно, потому что так бы я сделал несколько лет назад, а учиться на своих ошибках очень важно.

![Адаптивное боковое меню — Пример 3 (jQuery)](img/demo-jquery.png?raw=true&repo=off-canvas-navigation-for-responsive-website)

*Отзывчивое боковое меню использует jQuery-функцию ’.animate’ для анимации переходов. Короткая ссылка: [bit.ly/offcanvas3][17]*

[jQuery][18] — это средство, с которого многие фронт-энд разработчики начинают изучение JavaScript. Лично я — горячий поклонник (никогда не ругайте инструменты), но, к сожалению, jQuery имеет привычку делать вещи обманчиво простыми. Это скрывает сложность и затрудняет *понимание*.

Анимация нашего бокового меню на jQuery выглядит очень просто:

~~~~ .language-javascript
$('#nav-open-btn').on('click', function() {
    $('#inner-wrap').animate({ left: '70%' }, 500);
});

$('#nav-close-btn').on('click', function() {
    $('#inner-wrap').animate({ left: '0' }, 500);
});
~~~~

Визуально мы добились эффекта, но проверка на мобильных устройствах показывает задержки кадров. Производительность отвратительная.

Этот метод плох по нескольким причинам:

![Анимация изменения DOM через jQuery](img/jquery-animate.gif?raw=true&repo=off-canvas-navigation-for-responsive-website)

- Метод `.animate` библиотеки jQuery меняет атрибут `style` элемента на каждом кадре (как мы видим на GIF-изображении выше). Это заставляет браузер [перестраивать макет][19].
- Этот метод оставляет инлайн-стили в DOM-дереве, а они имеют очень **высокий приоритет** и будут переопределять любые наши CSS-стили. Это большая проблема, если для текущего размера области просмотра у нас используются другие стили.
- Нарушается **разделение интересов**, потому что стили определяются в JavaScript-файлах.

В целом, это кошмар с точки зрения поддержки и производительности. Есть лучший путь.

###Переходы на CSS

Отложим в сторону эксперимент с jQuery, я сейчас построю второй пример заново, в этот раз используя **CSS трансформации и переходы**. Это позволит нас получить более плавную анимацию боковой навигации с отличной производительностью.

![Адаптивное боковое меню — Пример 4](img/demo-final1.png?raw=true&repo=off-canvas-navigation-for-responsive-website)

*Финальный пример адаптивного бокового меню с CSS трансформациями и переходами. Короткая ссылка: [bit.ly/offcanvas4][20]*

- [Финальный пример][21]<br>
Производительность кардинально улучшена в сравнении с примером на jQuery.

####АНАЛИЗ ФИНАЛЬНОГО ПРИМЕРА

- Возврат к CSS, я снова использую класс `.js-nav` для переключения состояний навигации, не делая никаких изменений в стилях через JavaScript.
- Я произвожу постепенное улучшение, используя стили `.csstransforms3d` и `.csstransitions` (они устанавливаются на элемент документа при помощи [Modernizr][22]).
- Вместо сдвига меню при помощи отрицательного позиционирования (`left: -100%`), я использую свойство `transform`: `transform: translate3d(-100%, 0, 0)`.
- CSS переходы используют преобразование `transform` для анимации: `transition: transform 500ms ease`. Также я добавил ещё немного трансформаций для улучшения визуального эффекта.

При помощи Modernizr, произойдёт откат к [примеру 2][23] если браузер не поддерживает CSS трансформации и переходы. (В теории, я мог бы откатываться до jQuery-анимации, но в действительности делать этого не стоит.) Когда вы [скачиваете Modernizr][24], вы можете включить определение только того, что вам необходимо. Также он включает HTML5 shiv для IE. В целом, это очень полезный скрипт.

Преимущества тут огромные. Во-первых, за счёт переходов с 3D трансформациями, браузер может генерировать визуализацию слоёв при помощи [аппаратного ускорения][25]. Во-вторых, нам не нужно беспокоиться, что JavaScript переопределит свойства из стилей media-query. JavaScript нужен только для интерпретации взаимодействия с пользователем и он использует классы для управления состояниями, а CSS определяет изменения внешнего вида.

Мы можем глубже рассмотреть вопрос производительности используя инструменты разработчика в браузере Chrome. Приведённые ниже результаты относятся к настольному браузеру. Для исследования производительности мобильных браузеров, вы можете использовать [USB Remote Debugging][26] на устройствах Android.

####ПРОИЗВОДИТЕЛЬНОСТЬ JQUERY-АНИМАЦИИ

![Производительность jQuery-анимации в инструменте разработчика Chrome](img/demo-perf-jquery.png?raw=true&repo=off-canvas-navigation-for-responsive-website)

Четыре события отражают открытие и закрытие навигации два раза. На схеме желтым представлено выполнение JavaScript, фиолетовым — рендеринг (пересчёт стилей и макета), а зелёным — вывод на экран. На мобильных браузерах были бы значения значительно ниже 30 FPS. Я также тестировал на iPhone 3GS и мог буквально своими глазами видеть 3 FPS — настолько было медленно!

####ПРОИЗВОДИТЕЛЬНОСТЬ CSS ПЕРЕХОДОВ

![Производительность CSS переходов в инструменте разработчика Chrome](img/demo-perf-css.png?raw=true&repo=off-canvas-navigation-for-responsive-website)

Какая же разница! JavaScript служит только для управления действиями пользователя до и после переходов. Зелёные полоски — это тот минимум, что нужен браузеру, чтобы перерисовать переход с солидной частотой кадров, используя [GPU ускорение][27].

####ВОЗМОЖНЫЕ ПРОБЛЕМЫ

Как и всё остальное, новые веб-стандарты не совершенны.

В браузерах на базе WebKit, [сглаживание шрифтов][28] может переключиться с субпиксельного сглаживания на обычноеa, после применения CSS трансформаций или переходов. Это может привести к визуальному утончению текста, который многие дизайнеры даже предпочитают — но [это не то, что вы должны “фиксить”][29].

Также может возникнуть мерцание, если элемент находится в процессе трансформирования, но он пока без изменений. Чтобы этого избежать, всегда начинайте со значений по умолчанию, например `translate3d(0,0,0)` на элементе, который будет изменён позднее, таким образом будет подготовлен слой визуализации.

###Следующий шаг

В процессе дальнейшего улучшения, мы могли бы определить и использовать преимущества сложных жестов на тач-устройствах, например раздвигание, чтобы действительно приблизить эту реализацию к нативным приложениям. “Ближе” — это условно, но я действительно верю, что разрыв меньше, чем многим из нас кажется.

Также, по моему мнению, через этот разрыв *необходимо* построить мост.

Есть и другие умные способы увеличить скорость работы. Мобильные браузеры, как правило, ждут около 300 мс перед тем, как осуществить событие click. Райан Фиораванти из Google в своей великолепной статье “[Создание быстрых кнопок][30]” рассказал как сократить эту задержку.

[Эффекты сглаживания переходов][31] могут кардинально изменить визуальное представление и пользовательское восприятие происходящего. Когда элементы должны появляться, пружинить или ускоряться в процессе, Лея Веро предлагает полезный ресурс для генерации [кривых Безье][32] в пользовательских функциях сглаживания.

Надеюсь, эта статья продемонстрировала улучшения, которые могут быть осуществлены, если мы проявим старание в понимании используемых нами технологий.

####СКАЧАТЬ КОД

Итак, у нас есть трёхуровневое, адаптивное, интерактивное боковое меню. Я создал [GitHub репозиторий][33], где вы можете просмотреть код. Экспериментируйте с ним; не всё описано в этой статье, чтобы она не была слишком раздутой.

####ЧТО ЕЩЁ ПОЧИТАТЬ

Чтобы понять, почему я выбрал указанные выше методы, я рекомендую обратить внимание на следующие ресурсы (на английском языке):

- “[All You Need to Know About CSS Transitions][34],” Alex MacCaw
MacCaw gets into the specifics of CSS transitions and JavaScript.
- “[Why Moving Elements With translate() Is Better Than pos:abs top/left][35],” Paul Irish
A superb video and article examining the different movement techniques.
- “[Improving the Performance of Your HTML5 App][36],” Malte Ubl
Looks deep into the intricacies of performance.
- “[CSS3 vs jQuery Animations][37],” Siddharth Rao
This article puts both methods head to head.
- “[Understanding Hardware Acceleration on Mobile Browsers][38],” Ariya Hidayat
Goes under the hood with a technical review.
- “[Let’s Play With Hardware-Accelerated CSS][39],” Martin Kool
This article also introduces us to hardware acceleration.
- “[Scrolling Performance][40],” Paul Lewis
Looks at a related scenario.

[1]: http://trentwalton.com/2011/07/14/content-choreography/
[2]: http://www.mozilla.org/en-US/firefoxos/
[3]: http://www.google.com/intl/en/chrome/devices/
[4]: http://www.ubuntu.com/devices/phone
[5]: http://bradfrost.github.com/this-is-responsive/patterns.html
[6]: http://www.netmagazine.com/tutorials/build-smart-mobile-navigation-without-hacks
[7]: bit.ly/offcanvas1
[8]: http://dbushell.github.com/Responsive-Off-Canvas-Menu/step1.html
[9]: http://blog.cloudfour.com/the-ems-have-it-proportional-media-queries-ftw/
[10]: https://developer.mozilla.org/en-US/docs/Using_the_:target_selector
[11]: http://jakearchibald.github.com/sass-ie/
[12]: http://nicolasgallagher.com/mobile-first-css-sass-and-ie/
[13]: http://www.alwaystwisted.com/post.php?s=2012-08-06-a-sass-mixin-for-media-queries-and-ie
[14]: bit.ly/offcanvas2
[15]: http://dbushell.github.com/Responsive-Off-Canvas-Menu/step2.html
[16]: https://developer.mozilla.org/en-US/docs/Mozilla_event_reference/DOMContentLoaded_(event)
[17]: bit.ly/offcanvas3
[18]: http://jquery.com/
[19]: https://developers.google.com/speed/articles/reflow
[20]: bit.ly/offcanvas4
[21]: http://dbushell.github.com/Responsive-Off-Canvas-Menu/step4.html
[22]: http://modernizr.com/
[23]: http://dbushell.github.com/Responsive-Off-Canvas-Menu/step2.html
[24]: http://modernizr.com/download/
[25]: http://mobile.smashingmagazine.com/2012/06/21/play-with-hardware-accelerated-css/
[26]: https://developers.google.com/chrome/mobile/docs/debugging
[27]: http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome
[28]: http://www.usabilitypost.com/2012/11/05/stop-fixing-font-smoothing/
[29]: http://www.usabilitypost.com/2012/11/05/stop-fixing-font-smoothing/
[30]: https://developers.google.com/mobile/articles/fast_buttons
[31]: http://www.w3.org/TR/css3-transitions/#transition-timing-function-property
[32]: http://cubic-bezier.com/
[33]: https://github.com/dbushell/Responsive-Off-Canvas-Menu
[34]: http://blog.alexmaccaw.com/css-transitions
[35]: http://paulirish.com/2012/why-moving-elements-with-translate-is-better-than-posabs-topleft/
[36]: http://coding.smashingmagazine.com/2013/01/15/off-canvas-navigation-for-responsive-website/Improving%20the%20Performance%20of%20your%20HTML5%20App
[37]: http://dev.opera.com/articles/view/css3-vs-jquery-animations/
[38]: http://www.sencha.com/blog/understanding-hardware-acceleration-on-mobile-browsers/
[39]: http://mobile.smashingmagazine.com/2012/06/21/play-with-hardware-accelerated-css/
[40]: http://coding.smashingmagazine.com/2013/01/15/off-canvas-navigation-for-responsive-website/Scrolling%20Performance
